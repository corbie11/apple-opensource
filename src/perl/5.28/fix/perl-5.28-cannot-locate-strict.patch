diff --git a/MANIFEST b/MANIFEST
index 22b7d4a..32fe08c 100644
--- a/MANIFEST
+++ b/MANIFEST
@@ -5458,6 +5458,7 @@ t/io/errno.t			See if $! is correctly set
 t/io/errnosig.t			Test case for restoration $! when leaving signal handlers
 t/io/fflush.t			See if auto-flush on fork/exec/system/qx works
 t/io/fs.t			See if directory manipulations work
+t/io/getcwd.t			See if Internals::getcwd is sane
 t/io/inplace.t			See if inplace editing works
 t/io/iofile.t			See if we can load IO::File on demand
 t/io/iprefix.t			See if inplace editing works with prefixes
diff --git a/dist/PathTools/Cwd.pm b/dist/PathTools/Cwd.pm
index 58af935..f65cb54 100644
--- a/dist/PathTools/Cwd.pm
+++ b/dist/PathTools/Cwd.pm
@@ -659,6 +659,10 @@ if (exists $METHOD_MAP{$^O}) {
   }
 }
 
+# built-in from 5.30
+*getcwd = \&Internals::getcwd
+  if !defined &getcwd && defined &Internals::getcwd;
+
 # In case the XS version doesn't load.
 *abs_path = \&_perl_abs_path unless defined &abs_path;
 *getcwd = \&_perl_getcwd unless defined &getcwd;
diff --git a/dist/PathTools/t/cwd.t b/dist/PathTools/t/cwd.t
index 483b437..c056938 100644
--- a/dist/PathTools/t/cwd.t
+++ b/dist/PathTools/t/cwd.t
@@ -10,6 +10,7 @@ chdir 't';
 use Config;
 use File::Spec;
 use File::Path;
+use Errno qw(EACCES);
 
 use lib File::Spec->catdir('t', 'lib');
 use Test::More;
@@ -208,7 +209,15 @@ SKIP: {
 
     like($abs_path,      qr|$want$|i, "Cwd::abs_path produced $abs_path");
     like($fast_abs_path, qr|$want$|i, "Cwd::fast_abs_path produced $fast_abs_path");
-    like($pas,           qr|$want$|i, "Cwd::_perl_abs_path produced $pas") if $EXTRA_ABSPATH_TESTS;
+    if ($EXTRA_ABSPATH_TESTS) {
+        # _perl_abs_path() can fail if some ancestor directory isn't readable
+        if (defined $pas) {
+            like($pas,           qr|$want$|i, "Cwd::_perl_abs_path produced $pas");
+        }
+        else {
+            is($!+0, EACCES, "check we got the expected error on failure");
+        }
+    }
 
     rmtree($test_dirs[0], 0, 0);
     1 while unlink $file;
diff --git a/t/io/getcwd.t b/t/io/getcwd.t
new file mode 100644
index 0000000..f3ad58b
--- /dev/null
+++ b/t/io/getcwd.t
@@ -0,0 +1,22 @@
+#!./perl -w
+
+BEGIN {
+    chdir 't' if -d 't';
+    require "./test.pl";
+    set_up_inc('../lib');
+}
+
+use Config;
+
+$Config{d_getcwd}
+  or plan skip_all => "no getcwd";
+
+my $cwd = Internals::getcwd();
+ok(!defined $cwd || $cwd ne "",
+   "Internals::getcwd() returned a reasonable result");
+
+if (defined $cwd) {
+    ok(-d $cwd, "check a success result is a directory");
+}
+
+done_testing();
diff --git a/universal.c b/universal.c
index 2262939..6904719 100644
--- a/universal.c
+++ b/universal.c
@@ -986,6 +986,25 @@ XS(XS_re_regexp_pattern)
     NOT_REACHED; /* NOTREACHED */
 }
 
+#ifdef HAS_GETCWD
+
+XS(XS_Internals_getcwd)
+{
+    dXSARGS;
+    SV *sv = sv_newmortal();
+
+    if (items != 0)
+        croak_xs_usage(cv, "");
+
+    (void)getcwd_sv(sv);
+
+    SvTAINTED_on(sv);
+    PUSHs(sv);
+    XSRETURN(1);
+}
+
+#endif
+
 #include "vutil.h"
 #include "vxs.inc"
 
@@ -1020,6 +1039,9 @@ static const struct xsub_details details[] = {
     {"re::regnames", XS_re_regnames, ";$"},
     {"re::regnames_count", XS_re_regnames_count, ""},
     {"re::regexp_pattern", XS_re_regexp_pattern, "$"},
+#ifdef HAS_GETCWD
+    {"Internals::getcwd", XS_Internals_getcwd, ""},
+#endif
 };
 
 STATIC OP*
diff --git a/write_buildcustomize.pl b/write_buildcustomize.pl
index 8666a6b..1ee34ba 100644
--- a/write_buildcustomize.pl
+++ b/write_buildcustomize.pl
@@ -59,6 +59,9 @@ require Cwd;
 
 my $cwd  = Cwd::getcwd();
 
+defined $cwd
+  or die "$0: Can't determine current working directory\n";
+
 # lib must be last, as the toolchain modules write themselves into it
 # as they build, and it's important that @INC order ensures that the partially
 # written files are always masked by the complete versions.
